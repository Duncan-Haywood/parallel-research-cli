package output

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/duncan/parallel-research-cli/pkg/models"
)

// Formatter interface for different output formats
type Formatter interface {
	Format(essay *models.Essay) ([]byte, error)
}

// MarkdownFormatter implements Formatter for Markdown output
type MarkdownFormatter struct{}

func (f *MarkdownFormatter) Format(essay *models.Essay) ([]byte, error) {
	var buf bytes.Buffer
	
	// Header
	buf.WriteString(fmt.Sprintf("# %s\n\n", essay.Title))
	buf.WriteString(fmt.Sprintf("*Generated on %s*\n\n", essay.GeneratedAt.Format("January 2, 2006")))
	
	// Metadata
	buf.WriteString("## Metadata\n\n")
	buf.WriteString(fmt.Sprintf("- **Topic**: %s\n", essay.Metadata.Topic))
	buf.WriteString(fmt.Sprintf("- **Research Depth**: %s\n", essay.Metadata.ResearchDepth))
	buf.WriteString(fmt.Sprintf("- **Word Count**: %d\n", essay.WordCount))
	buf.WriteString(fmt.Sprintf("- **Generation Time**: %s\n", essay.Metadata.GenerationTime))
	buf.WriteString(fmt.Sprintf("- **Total Tokens Used**: %d\n", essay.Metadata.TotalTokens))
	buf.WriteString(fmt.Sprintf("- **Estimated Cost**: $%.2f\n\n", essay.Metadata.EstimatedCost))
	
	// Quality Metrics
	buf.WriteString("## Quality Metrics\n\n")
	buf.WriteString(fmt.Sprintf("- **Overall Score**: %.2f/1.00\n", essay.Metadata.QualityMetrics.OverallScore))
	buf.WriteString(fmt.Sprintf("- **Coherence**: %.2f\n", essay.Metadata.QualityMetrics.Coherence))
	buf.WriteString(fmt.Sprintf("- **Citation Quality**: %.2f\n", essay.Metadata.QualityMetrics.CitationQuality))
	buf.WriteString(fmt.Sprintf("- **Depth**: %.2f\n", essay.Metadata.QualityMetrics.DepthScore))
	buf.WriteString(fmt.Sprintf("- **Originality**: %.2f\n\n", essay.Metadata.QualityMetrics.Originality))
	
	buf.WriteString("---\n\n")
	
	// Main content
	buf.WriteString(essay.Content)
	buf.WriteString("\n\n")
	
	// Citations
	if len(essay.Citations) > 0 {
		buf.WriteString("## References\n\n")
		for i, citation := range essay.Citations {
			buf.WriteString(fmt.Sprintf("%d. ", i+1))
			if len(citation.Authors) > 0 {
				buf.WriteString(strings.Join(citation.Authors, ", ") + ". ")
			}
			buf.WriteString(fmt.Sprintf("*%s*. ", citation.Title))
			if citation.Source != "" {
				buf.WriteString(fmt.Sprintf("%s. ", citation.Source))
			}
			if citation.Date != "" {
				buf.WriteString(fmt.Sprintf("%s. ", citation.Date))
			}
			if citation.URL != "" {
				buf.WriteString(fmt.Sprintf("[%s](%s)", citation.URL, citation.URL))
			}
			buf.WriteString("\n")
		}
	}
	
	return buf.Bytes(), nil
}

// LaTeXFormatter implements Formatter for LaTeX output
type LaTeXFormatter struct{}

func (f *LaTeXFormatter) Format(essay *models.Essay) ([]byte, error) {
	tmpl := `\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{cite}

\title{{{.Title}}}
\author{Generated by Parallel Research CLI}
\date{{{.Date}}}

\begin{document}

\maketitle

\begin{abstract}
This document was generated using parallel AI research agents. 
Topic: {{.Metadata.Topic}}. 
Research depth: {{.Metadata.ResearchDepth}}.
Quality score: {{printf "%.2f" .Metadata.QualityMetrics.OverallScore}}/1.00.
\end{abstract}

{{.Content}}

{{if .Citations}}
\begin{thebibliography}{99}
{{range $i, $c := .Citations}}
\bibitem{ref{{$i}}} {{range $j, $a := $c.Authors}}{{if $j}}, {{end}}{{$a}}{{end}}. 
\emph{{{$c.Title}}}. {{$c.Source}}. {{$c.Date}}.
{{if $c.URL}}\url{{{$c.URL}}}{{end}}
{{end}}
\end{thebibliography}
{{end}}

\end{document}`

	t, err := template.New("latex").Parse(tmpl)
	if err != nil {
		return nil, err
	}
	
	data := struct {
		*models.Essay
		Date string
	}{
		Essay: essay,
		Date:  essay.GeneratedAt.Format("January 2, 2006"),
	}
	
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return nil, err
	}
	
	return buf.Bytes(), nil
}

// HTMLFormatter implements Formatter for HTML output
type HTMLFormatter struct{}

func (f *HTMLFormatter) Format(essay *models.Essay) ([]byte, error) {
	tmpl := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <style>
        body {
            font-family: Georgia, serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 { color: #333; }
        .metadata {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .quality-score {
            font-size: 24px;
            font-weight: bold;
            color: {{if gt .Metadata.QualityMetrics.OverallScore 0.8}}green{{else if gt .Metadata.QualityMetrics.OverallScore 0.6}}orange{{else}}red{{end}};
        }
        .citations {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ccc;
        }
        blockquote {
            border-left: 4px solid #ccc;
            padding-left: 15px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>{{.Title}}</h1>
    
    <div class="metadata">
        <p><strong>Generated:</strong> {{.GeneratedAt.Format "January 2, 2006"}}</p>
        <p><strong>Topic:</strong> {{.Metadata.Topic}}</p>
        <p><strong>Word Count:</strong> {{.WordCount}}</p>
        <p><strong>Quality Score:</strong> <span class="quality-score">{{printf "%.2f" .Metadata.QualityMetrics.OverallScore}}/1.00</span></p>
        <p><strong>Estimated Cost:</strong> ${{printf "%.2f" .Metadata.EstimatedCost}}</p>
    </div>
    
    <div class="content">
        {{.Content}}
    </div>
    
    {{if .Citations}}
    <div class="citations">
        <h2>References</h2>
        <ol>
        {{range .Citations}}
            <li>
                {{range $i, $author := .Authors}}{{if $i}}, {{end}}{{$author}}{{end}}.
                <em>{{.Title}}</em>.
                {{.Source}}.
                {{.Date}}.
                {{if .URL}}<a href="{{.URL}}">{{.URL}}</a>{{end}}
            </li>
        {{end}}
        </ol>
    </div>
    {{end}}
</body>
</html>`

	t, err := template.New("html").Parse(tmpl)
	if err != nil {
		return nil, err
	}
	
	var buf bytes.Buffer
	if err := t.Execute(&buf, essay); err != nil {
		return nil, err
	}
	
	return buf.Bytes(), nil
}

// GetFormatter returns the appropriate formatter for the given format
func GetFormatter(format models.OutputFormat) (Formatter, error) {
	switch format {
	case models.FormatMarkdown:
		return &MarkdownFormatter{}, nil
	case models.FormatLaTeX:
		return &LaTeXFormatter{}, nil
	case models.FormatHTML:
		return &HTMLFormatter{}, nil
	default:
		return nil, fmt.Errorf("unsupported format: %s", format)
	}
}